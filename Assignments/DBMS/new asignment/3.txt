1. What are constraints in SQL? List and explain the different types of constraints

Constraints in SQL are rules or restrictions that are applied to columns in a database table to ensure the integrity, accuracy, and reliability of the data. These constraints help in defining the type of data that can be stored in a table, how it relates to other data, and how it behaves when changes are made to the data. Constraints can be applied at the column level (to a specific column) or table level (across multiple columns).

Common Types of SQL Constraints
NOT NULL Constraint

Purpose: Ensures that a column cannot have a NULL value. It forces the user to provide a value for this column when inserting or updating records.
Use case: When a column is essential and must always contain a valid value (e.g., student_name, date_of_birth).
Example:

CREATE TABLE students (
    student_id INT NOT NULL,
    student_name VARCHAR(100) NOT NULL
);
PRIMARY KEY Constraint

Purpose: Uniquely identifies each record in a table. A primary key column cannot have NULL values, and it must contain unique values.
Use case: To ensure that each record in the table is uniquely identifiable (e.g., student_id for a students table).
Example:

CREATE TABLE students (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(100)
);
FOREIGN KEY Constraint

Purpose: Ensures referential integrity by linking a column in the current table (called the child table) to a column in another table (called the parent table). It ensures that the value in the child table exists in the parent table.
Use case: To represent relationships between tables, such as linking a student_id in a grades table to the student_id in the students table.
Example:

CREATE TABLE grades (
    grade_id INT PRIMARY KEY,
    student_id INT,
    grade VARCHAR(2),
    FOREIGN KEY (student_id) REFERENCES students(student_id)
);
UNIQUE Constraint

Purpose: Ensures that all values in a column (or a combination of columns) are unique, meaning no two rows can have the same value for that column.
Use case: When a column must contain unique data, such as an email address or student identification number.
Example:

CREATE TABLE students (
    student_id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE
);
CHECK Constraint

Purpose: Ensures that the values in a column meet a specific condition. The CHECK constraint allows for custom validation rules.
Use case: To enforce business rules, like making sure the age of a student is greater than 0.
Example:

CREATE TABLE students (
    student_id INT PRIMARY KEY,
    age INT CHECK (age > 0)
);
DEFAULT Constraint

Purpose: Specifies a default value for a column when no value is provided during an INSERT operation.
Use case: To provide a default value for a column when the user does not specify one (e.g., a default status for new students).
Example:

CREATE TABLE students (
    student_id INT PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'active'
);
INDEX Constraint

Purpose: While not technically a constraint in the strictest sense, indexes are used to improve the speed of retrieval operations on a table. Indexes can be created on one or more columns of a table to allow for faster queries.
Use case: To speed up search queries on large tables, especially when frequently searching by a specific column.
Example:

CREATE INDEX idx_student_name ON students(student_name);

2. How do PRIMARY KEY and FOREIGN KEY constraints differ?

The PRIMARY KEY and FOREIGN KEY constraints are both used to maintain data integrity in relational databases, but they serve different purposes and have distinct characteristics. Here's a detailed comparison:

1. PRIMARY KEY
Purpose: A PRIMARY KEY is used to uniquely identify each record in a table. It ensures that each row in the table is unique and not duplicated.

Characteristics:

A PRIMARY KEY column must contain unique values (no duplicates).
A PRIMARY KEY column cannot contain NULL values; every row must have a value in the primary key column(s).
A table can have only one PRIMARY KEY, but the primary key can consist of one or more columns (this is called a composite primary key).
Typically, a primary key is created on the column that uniquely identifies the record, like an ID field.
Example:


CREATE TABLE students (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(100)
);
In this example, the student_id column is the primary key, meaning each student_id must be unique and not NULL.

2. FOREIGN KEY
Purpose: A FOREIGN KEY is used to establish and enforce a link between the data in two tables. It ensures referential integrity, meaning that the values in a foreign key column must match values in a primary key or a unique column in another table.

Characteristics:

A FOREIGN KEY column may contain duplicate values (it does not need to be unique).
A FOREIGN KEY column can contain NULL values, representing the absence of a relationship (depending on whether the relationship allows NULL).
A table can have multiple FOREIGN KEY constraints that reference different primary keys (or unique keys) from other tables.
A foreign key enforces a relationship between tables by pointing to a primary key in another table, ensuring that the relationship between records is valid.
Example:


CREATE TABLE enrollments (
    enrollment_id INT PRIMARY KEY,
    student_id INT,
    course_id INT,
    FOREIGN KEY (student_id) REFERENCES students(student_id)
);
In this example:

The student_id column in the enrollments table is a foreign key that references the student_id column in the students table.
This means that for every student_id in the enrollments table, it must correspond to an existing student_id in the students table.

3. What is the role of NOT NULL and UNIQUE constraints?

The NOT NULL and UNIQUE constraints are both used in SQL to enforce data integrity, but they serve different purposes. Here's an explanation of each:

1. NOT NULL Constraint
Role: The NOT NULL constraint ensures that a column cannot have a NULL value. In other words, it forces the user to provide a valid (non-null) value when inserting or updating a record in the table.

Purpose: It is used when a column's data is required for every record, meaning it cannot be left empty. This constraint is often applied to fields that are critical to the business logic or operations, such as names, dates, or IDs.

Behavior:

When a column is defined as NOT NULL, every insert or update operation must provide a value for that column. Failure to do so will result in an error.
The NOT NULL constraint does not impose any restriction on the values' uniqueness. Multiple records can have the same value for a NOT NULL column as long as those values are valid and non-null.
Example:


CREATE TABLE students (
    student_id INT NOT NULL,
    student_name VARCHAR(100) NOT NULL,
    age INT
);
In this example:

The student_id and student_name columns are defined with the NOT NULL constraint, meaning each student must have a student_id and student_name value. The age column does not have this constraint, so it can be left NULL.
2. UNIQUE Constraint
Role: The UNIQUE constraint ensures that all the values in a column (or a combination of columns) are unique across the entire table. No two rows can have the same value for that column (or group of columns if the UNIQUE constraint is defined on multiple columns).

Purpose: It is used to enforce uniqueness in a column where duplicates are not allowed, such as email addresses, phone numbers, or user IDs. The UNIQUE constraint helps to prevent the insertion of duplicate data in a column.

Behavior:

Unlike the PRIMARY KEY constraint, a column with a UNIQUE constraint can still accept NULL values (though this behavior can depend on the database system). However, multiple NULL values are allowed in a column with a UNIQUE constraint because NULL is not considered a duplicate.
A table can have multiple UNIQUE constraints on different columns, whereas a table can only have one PRIMARY KEY.
Example:



CREATE TABLE students (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(100),
    email VARCHAR(100) UNIQUE
);
In this example:

The student_id column is the PRIMARY KEY, ensuring each student has a unique ID.
The email column has a UNIQUE constraint, ensuring no two students can have the same
email address in the table.

